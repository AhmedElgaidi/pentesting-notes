# Host Header Injection:

## What is "HTTP header"?

It's an additional information sent over the request/ response during communication

```
    <key>: <value>
```

## What is "host header" ?

- It's a piece of information that you can use in addition to the IP address and the port number (if not specified, the default is 80) to uniquely identify a web domain
- It represents the domain name that the client wants to access.
- The Host header is important to enable routing traffic to virtual hosts (It helps route each request to the correct origin server).
- This header is essential, because it's very common for servers to host multiple (websites/ applications) at the same IP address. So, when the server receives a request, it checks the host header parameter, to determine which domain (back-end infrastructure) needs to process this request and then forward it.
- **Note:** There are two main ways, where multiple websites/ web apps accessible under same IP address:
  1. **Virtual host:**
     When multiple website or web applications are hosted on one server, they are called "Virtual Hosts". The server has a single IP address in this scenario, and the received requests are routed to the relevant domain.
  2. **Intermediary system:**
     Alternatively, multiple websites can be found on one IP address, when intermediary systems are used. In this case, the website may be located on a separate server, but it's accessed via an intermediary such as:
      - Reverse proxy.
      - Content Delivery Network (CDN).
      - Web syndication.
      [What is web syndication | w3schools.com](https://www.w3schools.com/xml/xml_rss.asp)
      ![Web syndication](https://images.slideplayer.com/20/6014914/slides/slide_3.jpg)
      - Or any other form of traffic routing.

## What is "Host Header Injection" ?

- HTTP host header attacks exploit vulnerable websites that handle the host header value in an unsafe way.
- If the server is implicitly trusts the host header, and fails to validate or escape it properly, the attacker may use this input to inject harmful payloads that affect server-side behavior.

# Impact:

1. ##### Web Cache Poisoning:
   Its's a technique used by attacker to manipulate web-cache to serve poisoned content to anyone requests pages.
   For this to occur, the attacker needs to poison a caching proxy run by the site itself, or downstream providers, content delivery networks (CDNs) or any caching mechanism between the client and the server. So, the cache will then serve the poisoned content to anyone requesting it (**So. Now, the target is the proxy!**).
2. ##### Password Reset Poisoning (Lead to account takeover):
   A common way to implement a password reset functionality is to use URL token (Generate a token and send it in an email to the user mailbox).
   What if the attacker manipulates the host header in this password-reset request?
   **If** the web application is vulnerable to the host header injection attack (Use host header value when creating the reset link), the attacker can then poison this reset link that's sent to the victim. So, if the user clicks on the password-reset link sent to his mailbox, then the token which is generated, instead of reaching the target website server, it reaches the attacker server, so he can use this token until it's expired and takeover the victim's account.
   Example:
   ```
   // Make an HTTP request to the /reset-password endpoint with a tampered host header
   POST /reset-password HTTP/1.1
   Host: attacker.com
   [...]
   email: test@gmail.com
   // Now, if the web app is vulnerable, it's now poisoned, and when any user wants to reset his password (email sent to him with token), once he clicks the link, the token is sent to the attacker server not the real server and if the attacker was quick, he can takeover the user account.
   ```
3. ##### Access Internal (private) Hosts:
   In the real world, the web server may have multiple virtual hosts, may one of them is not intended to be accessed externally
   Example:
   An organization may have a single web server on there internal network, which hosts both their public website (www.example.com) and internal intranet (private network) (intranet.example.com, but this record only exists in the internal DNS server, which means you can't access it outside this private network directly from the browser). So, the attacker can exploit the host header of course if it's vulnerable to access this private intranet by
   ```
   GET / HTTP/1.1
   Host: intranet.example.com // Simple as that
   [...]
   // This also can be done by overriding DNS resolution of the public IP
   ```
4. ##### Server Side Request Forgery (SSRF);
5. ##### Insecure Redirects:
6. ##### Dispatch requests to the first virtual host on the list:
   When we host multiple web apps/ websites (virtual hosts) on a web server, and it can't recognize the received traffic, it forward them to the first virtual host

## How to find?

There are many ways to test for this important vulnerability (Observe the response status code, if 200, then it's vulnerable):

1. ##### Change the host header:
   ```
   GET / HTTP/1.1
   Host: attacker.com
   [...]
   ```
2. ##### Duplicate the host header:
   ```
   GET / HTTP/1.1
   Host: target.com
   Host: attacker.com
   [...]
   ```
3. ##### Add line wrapping (Indentation):
   ```
   GET / HTTP/1.1
       Host: target.com
   Host: attacker.com
   [...]
   ```
4. ##### Add host override headers:
   ```
   GET / HTTP/1.1
   X-Forwarded-For: attacker.com
   X-Forwarded-Host: attacker.com
   X-Forwarded-Proto: attacker.com
   X-Forwarded-Server: attacker.com
   X-Client-IP: attacker.com
   X-Remote-IP: attacker.com
   X-Remote-Addr: attacker.com
   X-Host: attacker.com
   X-HTTP-Host-Override Forwarded: attacker.com
   [...]
   ```
5. ##### Supply an absolute URL:

   ```
   GET https://www.attacker.com/ HTTP/1.1
   Host: attacker.com
   [...]
   ```

## How to prevent it?

**Note:** The host headers are user controllable (user can change it with any proxy as burp), so don't trust it as any user input in general

1. Validate and sanitize the Host Header value (**When validating check if the request comes from the original target host or not [Check this package for host validation in node.js](https://www.npmjs.com/package/host-validation)**).
2. Whitelist permitted hostname or domains (Delivered by most modern frameworks).
3. Be cautious with absolute URLs (**The domain must be specified on the server side configuration file and take it from there, not from the Host header value**).
4. Don't permit host header override (This depends on the intermediary systems/ components deployed in your architecture).
5. Avoid using Host header value in the application logic as much as possible.
   - what cases that host value could be used?
      - To generate links.
      - Import scripts.
      - Determine the proper redirect address.
      - Generate password reset links.
      **Generally**, any think that may utilize the host value in it's response processing. 
6. Avoid using public and internal (private) virtual hosts on the same server (As host header injection may lead to access to those internal virtual hosts).
## Some useful discussion:
- [Do relative paths mitigate HTTP Host Header attacks?](https://security.stackexchange.com/questions/257106/do-relative-paths-mitigate-http-host-header-attacks/257107#257107?newreg=83b18640dff143188835b985d450d5ce)
- [Per Origin Host Header | when using intermediary systems as load balancers
](https://blog.cloudflare.com/per-origin-host-header-override/)
- [Absloute VS. Relative paths](https://www.coffeecup.com/help/articles/absolute-vs-relative-pathslinks/) (Relative is generally better as it decreases the surface area of the host header injections).
- []

## Some useful write ups:

1. []()
2. []()

