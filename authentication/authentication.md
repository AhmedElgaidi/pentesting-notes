# How to secure your authentication mechanisms?
[ 1 ] Take care with user credentials:
    - Never send login data (credentials) over unencrypted connection (HTTP request).
    - Enfore http request to be redirected to HTTPS requests.
    - Make sure no usernames or emails addresses are disclosed either through (accesible profile or HTTP respones).
[ 2 ] Don't count on users for security:
    - Enforce user to behave securly as much as possible by stricting password policy.
    - Use packages such as zxcvbn to give the user a real time feedback about his password strength.
[ 3 ] Prevent user enumeration:
    - Never reveal your users username.
    - Always return generic error messages.
    - Always return the same HTTP status code.
    - Always make the responses times in different senarios undistingiushable as much as possible.
[ 4 ] Implement robust brute-force protection:
    - Implement IP-based user rate limiting (To decrease the number of attempts, don't prevent).
    - Force the user to complete a CAPTCHA test with every login attempt after a certain limit is reached.
    - Note: There is no way to eliminate the brute-force attack, it's just make it hard for the attacker by
    making it more manual and slow.
[ 5 ] Triple-check your verification logic
    - During development, try as much as possible to verify and audit your verification or validation logic.
[ 6 ] Don't forget supplementary functionality:
    - Always add more security checks after the user is got verified as the attacker can register with his own email and explore and map your system, like at password reset/ change endpoints.
[ 7 ] Implement proper multi-factor authentication:
    - Multi-factor authentication is more secure than password-based authentication.
    - Note: verifying multiple instances of the same factor is not true multi-factor authentication.

//========================================================
# Vulnerabilities in password based login:
Note: In these apps, users either register for an account themselves or they are assigned an account by an administrator. So, they are depnending on the credentials, once they obtained/ guessed => account/ website is compromised.
## This may happen either by:
[ 1 ] Brute force attacks:
    - Is when an attacker uses a system of trial and error in an attempt to guess valid user credentials.
    - It's done by using wordlists and with certain tools that make it really serious.
    [ 1 ] Brute-forcing usernames:
        - Make the guess process hard as much as possible.
        - Don't follow a paterrn in creating usernames such as: firstName.lastName@company.com or admin@company.com
        - Never return any data in the HTTP respnes as we said before.
    [ 2 ] Brute-forcing passwords:
        - Follow some password policy that makes it hard to crack (not to eliminate) such as:
            - A minimum number of characters.
            - A mixture of lower and uppercase characters.
            - At least one special characters.
        - Make user change his password on regular periods.
        - Note: craking passwards as human is easier than as computers, as we can narrow down the wordlist
        by following some patterns that human may follow such as mypassword to MyPassword1 and after making him audit his password after some time, he may change it to something like this MyPassowrd2
    [ 3 ] Usernames enumeration:
        - is when an attacker is able to observe changes in the website's behavior in order to identify whether a given username is valid.
        - This may happen on login/ sign up pages, where the attacker look at these things and make a short list of valied usernames: 
            [ 1 ] Status code: 
                - The best practice for websites to always return the same status code regardless of the outcome, as the status code is likely to be same for the majority of attempts/ guesses, because most of them are wrong, the responses that return different status code is valid guess.
            [ 2 ] Error message:
                - Never send different formats of error messages to the user (both usernames and password are wrong, the password is wrong).
                - The best practice is to use identical generic error messages in both cases (Be aware of the message, don't change even a dot)
            [ 3 ] Response time: 
                - If there is more time for some requests to be handled, this means that username might be valid and the server is verifing the password or something like that. So, always pay atention to the time of responses during enumuration.
    [ 4 ] Flawed brute-force protection:
        [ 1 ] 
            - We need to protect our endpoints aganist brute-forcing to slow down the rate by making as tricky as much as possible to automate the process
            - The 2 most common ways for doing this is:
                - Lock the user account after certain failing attempts.
                - Block the user remote IP, if he makes too many login attempts in quick succession.
            Note: to bypass the IP address blocking, login to your account after certain counts to make the counter of failed attempts resets and try again and so on (Some websites have this flaw).
            So, injecting yor own credentails in the used wordlist, would make the defence meaningless.
        [ 2 ] Account locking:
            - Some website lock user accounts after observing some suspicious activity as brute-forcing. The attacker use this protection aganist them to enumerate the credentials.
            - Note: The attacker uses a gathered valid useranmes and do brutefocring aganist them by (3 common passwords if the number of attempts before locking is 3 for example).
            - Note: Account locking also fails to protect against credential stuffing attacks. The attacker uses a valid usernames and passwords dictionaries from any data breach and init a single automated attack, so the account locking wouldn't be helpful as he tries only with single account and if his ip is block, he can change it on a regualr baseses during the attack.
    [ 5 ] User rate limiting:
        - making too many login requests within a short period of time causes your IP address to be blocked.
        - The IP can only be unblocked in one of the following ways:
            [ 1 ] Automatically after a certain period of time has elapsed.
            [ 2 ] Manually by:
                - Website admin.
                - attacker successfully completing a CAPTCHA.
        Note: User rating limiting is better than account locking as it's less vulnerable to username enumeration and DOS attacks (but, still not 100 % defence).
        
        Note: Some websites slow down requests rate from certain IP. In some cases, you can bypass this defence, if you can work out how to guess multiple passwords with single request. (More info with less try/effort).
# What is HTTP basic authentication?
- the client receives an authentication token from the server, which is constructed by concatenating the username and password, and encoding it in Base64. This token is stored and managed by the browser, which automatically adds it to the Authorization header of every subsequent request 
[x] Authorization: Basic base64(username:password)
- This type of authentication is really weak and easy to be compromised and no website are using it anymore in their authentication cycle (Weak + Old). But, be careful, some developers may use this approach for some end points, and it's a good step for the attacker to increase his attack layer (More understandin the website flow, enumeration and so on).

# note: you can bypass bruteforce protection by sending multiple credentials in the same request, in json format and the password array of suggested passwords
{
    "name": "ahmed",
    "password": [
        "one",
        "two"
        ....
    ]
}

//======================================

# Vulnerabilities in multi-factor authentication:
- Many websites rely exclusively on single-factor authentication using a password to authenticate users. However, some require users to prove their identity using multiple authentication factors.
- Usually two-factor authentication (2FA) is based on something you know and something you have.
- What is the problem that developers do? they use 2FA in a bad approach. The benefits of 2FA authentication is to authenticate by 2 different factors, what what some developers do is they authenticate the same factor multiple times as email-based 2FA (Although the user has to provide a password and a verification code, accessing the code only relies on them knowing the login credentials for their email account. Therefore, the knowledge authentication factor is simply being verified twice.)

# Two-factor 2FA authentication tokens:
- Verification codes are usually read by the user from a physical device.
- These dedicated devices also have the advantage of generating the verification code directly. It is also common for websites to use a dedicated mobile app, such as Google Authenticator.

# Note: some websites send verification codes to a user's mobile phone as a text message and this bad why?
- the code is being transmitted via SMS rather than being generated by the device itself and this creates the potential for the code to be intercepted.
- There is also a risk of SIM swapping, whereby an attacker fraudulently obtains a SIM card with the victim's phone number. The attacker would then receive all SMS messages sent to the victim, including the one containing their verification code. 

# Bypassing two-factor authentication:
If the user is first prompted to enter a password, and then prompted to enter a verification code on a separate page, the user is effectively in a "logged in" state before they have entered the verification code. In this case, it is worth testing to see if you can directly skip to "logged-in only" pages after completing the first authentication step. Occasionally, you will find that a website doesn't actually check whether or not you completed the second step before loading the page.

# Flawed two-factor 2FA verification logic:
This means that after a user has completed the initial login step, the website doesn't adequately verify that the same user is completing the second step.
1- the user logs in with their normal credentials in the first step 
2- They are then assigned a cookie that relates to their account, before being taken to the second step of the login process.
3- When submitting the verification code, the request uses this cookie to determine which account the user is trying to access.
So, where is the flaw?
4- In this case, an attacker could log in using their own credentials but then change the value of the account cookie to any arbitrary username when submitting the verification code

POST /login-steps/second HTTP/1.1
Host: vulnerable-website.com
Cookie: account=victim-user
...
verification-code=123456

5- This is extremely dangerous if the attacker is then able to brute-force the verification code as it would allow them to log in to arbitrary users' accounts based entirely on their username. They would never even need to know the user's password.

# note: Some website, when you enter invalid verification code for certain time, log you out. But, this is not effective in practical, as the attacker can automate the process of bruteforcing by creating "macros" in burp intruder and may use turbo intruder to accelerate the process of bruteforcing.